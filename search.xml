<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css之flex布局]]></title>
    <url>%2F2019%2F01%2F16%2Fcss-flex-layout%2F</url>
    <content type="text"><![CDATA[1、背景 我们知道一切dom元素对css而言都是一个盒子，css正是以盒子模型为基础进行渲染CSSDom，而页面布局一直是css一个应用重点，那么如何通过css实现水平居中和垂直居中？相信实现的方法有很多，如table，float等，但它们都有各自的缺陷。然而当flex出现后，一切都变得相当的简约而不简单，优雅而不优越，因为它也存在兼容性问题。12345.centerContainer &#123; display: flex; justify-content: center; align-items: center;&#125; 浏览器兼容性方面：IE10+ 详情点击这里 2、概念flex由两个核心概念构成：容器和轴。容器包括父容器和子容器，轴分为主轴和交叉轴（即以横轴为主轴时，纵轴为交叉轴；以纵轴为主轴时，横轴为交叉轴；交叉轴=主轴逆时针90度）。flex属性一共有12个，父容器和子容器对应的属性各6个。 3、属性介绍父容器属性 1) flex-direction (常用)2) justify-content (常用)3) align-items (常用)4) align-content5) flex-warp6) flex-flow 子容器属性 1) align-self (常用)2) flex (常用)3) flex-grow4) flex-shrink5) flex-basis6) order 3.1.常用属性介绍1) flex-direction功能：flex-direction属性用于确定主轴的方向使用：1234.box &#123; display: flex; flex-direction: row | row-reverse | column | column-reverse;&#125; 属性值 说明 row 主轴为水平方向，起点在左端（默认值） row-reverse 主轴为水平方向，起点在右端 column 主轴为垂直方向，起点在上 column-reverse 主轴为垂直方向，起点在下 2) justify-content功能：justify-content属性用于定义如何沿着主轴方向排列子容器使用：1234.box &#123; display: flex; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 属性值 说明 flex-start 左对齐（默认值） flex-end 右对齐 center 居中 space-bettween 两端对齐，子容器之间间隔相等 space-around 均匀分布，首尾两端的子容器到父容器的距离是子容器间距的一般 3) align-items功能：justify-content属性用于定义如何沿着主轴方向排列子容器使用：1234.box &#123; display: flex; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 属性值 说明 flex-start （默认值）左对齐 flex-end 右对齐 center 居中 space-bettween 两端对齐，子容器之间间隔相等 space-around 均匀分布，首尾两端的子容器到父容器的距离是子容器间距的一般 3.2.进阶属性介绍4、总结常用的属性如下：flex-direction, justify-content, align-items, align-self, flex进阶的属性如下：align-content, flex-warp, flex-flow, order, flex-grow, flex-shrink, flex-basis 参考一劳永逸的搞定 flex 布局：https://juejin.im/post/58e3a5a0a0bb9f0069fc16bbFlex 布局教程：语法篇：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>flex布局</tag>
        <tag>css3</tag>
        <tag>css居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jmeter介绍]]></title>
    <url>%2F2019%2F01%2F07%2Fjmeter1%2F</url>
    <content type="text"><![CDATA[1、简介 测试系统的负载能力和性能测试工具纯Java开发支持多种类型服务和协议界面模式和命令行模式扩展性强 2、安装和启动下载地址：https://jmeter.apache.org/download_jmeter.cgi历史版本：https://archive.apache.org/dist/jmeter/binaries/加压后双击运行 jmeter-3.3/bin/jmeter.bat 即可 3、各元件介绍jmeter有许多的元件，如图： Jmeter元件主要包括： 1.逻辑控制器（controller）2.配置元件3.定时器4.前置处理器5.采样器（Sampler）6.后置处理器7.断言8.监听器 Jmeter各元件优先级顺序： 1.配置元件2.前置处理器3.定时器4.采样器（Sampler）5.后置处理器6.断言7.监听器 Jmeter各元件是以控制器（controller）和采样器（sampler）为中心，其他元件都是围绕这两个元件进行逻辑处理。采样器一般内嵌在逻辑控制器Controller中]]></content>
      <categories>
        <category>jmeter</category>
      </categories>
      <tags>
        <tag>jmeter学习笔记</tag>
        <tag>jmeter</tag>
        <tag>性能压测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM编程之渲染引擎原理]]></title>
    <url>%2F2019%2F01%2F04%2Fhpjavascript3-1%2F</url>
    <content type="text"><![CDATA[1、背景 浏览器引擎主要由两部分组成：渲染引擎（rendering engine）和js解析器（javascript interpreter） 参考浏览器工作原理：http://domenicodefelice.blogspot.com/2015/08/how-browsers-work.html?t=2]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>高性能JavaScript</tag>
        <tag>DOM编程</tag>
        <tag>渲染引擎原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域管理原理]]></title>
    <url>%2F2019%2F01%2F02%2Fhpjavascript2-1%2F</url>
    <content type="text"><![CDATA[1、执行环境context执行函数add时，会创建一个被称为执行环境（execution context）的内部对象，一个执行环境定义了一个函数执行时的环境。函数每次执行时对应的执行环境都是独一无二的，所以多次调用同一个函数会创建多个执行环境。当函数执行完成时，执行环境就会被销毁 1234function add(num1, num2)&#123; var sum = num1 + num2; return ;&#125; 2、作用域链与活动对象每个执行环境都有自己的作用域链，用于解析标识符。如图 当执行环境被创建时，它的作用域链初始化为当前运行函数的[Scope]属性中的对象。这些值按照它们出现在函数中的顺序，被复制到执行环境的作用域链中这个过程一旦完成，一个称为“活动对象”(activation Object)的新对象在执行环境中创建好了如上图，活动对象与其他的对象在一个队列中，作用链的最顶端为活动对象，当执行环境被销毁，活动对象也随之销毁 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程： 搜索过程从作用域链头部开始搜索（当前活动对象）该变量标识符 如找到则使用，直接使用该标识符 如没有找到，继续搜索作用域链的下一个对象，直到找到为止 若作用域链中所有对象中都没有找到该标识符，那么该标识符被视为未定义的。 全局变量总是存在于执行环境作用域链的最末端，因此它是最远的。要想提高代码性能，请将函数内的全局变量转化成局部变量，提高读取标识符解析速度。 3、改变作用域链一般来说，一个执行环境的作用域链是不会改变的，但是有两个语句可以使其发生改变：1.with语句2.try-catch中catch子句 4、优化JavaScript代码策略1.访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢 2.由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨域变量更快。变量在作用域链的位置越深，访问的速度越慢。由于全局变量总处于作用域链的最末端，因此访问的速度也是最慢的 3.避免使用with语句，因为它会改变执行环境的作用域链，同样，try-catch语句中的catch子句也有同样的影响，因此要小心使用 4.嵌套的对象成员会明显影响性能，因此尽量少用 5.属性和方法在原型链中的位置越深，访问它的速度也就越慢 6.通常来说，你可以通过把常用的对象成员，数组元素，跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问的速度更快。以空间换时间的代价，需要自己权衡]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>高性能JavaScript</tag>
        <tag>作用域</tag>
        <tag>执行环境context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无阻塞加载js文件]]></title>
    <url>%2F2019%2F01%2F02%2Fhpjavascript1%2F</url>
    <content type="text"><![CDATA[代码11&lt;script type=&quot;text/javascript&quot; src=&quot;file1.js&quot;&gt;&lt;/script&gt; 代码2 1234var script = document.createElement(&quot;script&quot;);script.type = &quot;text/javascript&quot;;script.src = &quot;file1.js&quot;document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script); 代码1与代码2的异同： 代码1在执行过程中，文件下载后会立刻执行，堵塞页面的其他进程（如其他下载进程） 代码2在执行过程中，文件下载和执行过程不会堵塞页面的其他进程，直到DOM加载完成，因此该方法可以与其他资源并行下载 有多种无堵塞下载JavaScript的方法： 1. 使用script标签的defer属性 2. 使用动态创建的script元素来下载并执行代码 3. 使用XHR对象下载JavaScript代码并注入页面中 以上三种方法各有缺点： 1-1) 支持的浏览器较少 2-1) IE内核浏览器需要额外处理 3-1) 不支持CDN下载]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>高性能JavaScript</tag>
        <tag>无堵塞加载</tag>
      </tags>
  </entry>
</search>
