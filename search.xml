<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js运行机制]]></title>
    <url>%2F2019%2F04%2F24%2Fjs-thread-event-lood%2F</url>
    <content type="text"><![CDATA[1、背景]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>运行机制</tag>
        <tag>事件循环</tag>
        <tag>js线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的javascript系列-深入理解闭包]]></title>
    <url>%2F2019%2F04%2F24%2Fyou-dont-know-js-2%2F</url>
    <content type="text"><![CDATA[1、背景对于那些有一点javascript使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作对javascript编程艺术的升华，掌握它将会揭开javascript神秘的一面，帮助你加深理解javascript。网上有很多的文章也介绍过，但看了之后，很快就忘了，始终不得其奥义。归根到底，闭包似乎有一种只可意会不可言传的味道，直到有一天我接触到了作用域的概念，我才深深地理解了它的奥妙，也就是我要传给你的秘诀：函数嵌套和垮作用域引用。 2、闭包的奥义其实，闭包无处不在。不用怀疑，其实你的代码中也存在，只是它认识你，你不认识它罢了。 下面就让我们来揭开它的神秘面纱吧。 根据《你不知道的JavaScript》一书对闭包的定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 好了，先让我们告别天书，用人类的语言进行交流吧，先看下面一个例子：123456789101112// 例子Afunction par() &#123; var a = 1; function chi() &#123; console.log(a); &#125; chi();&#125;par(); 上述例子是一个非常普通的代码例子，也许你的代码中类似的例子遍地都是，那么它是闭包吗？ 确切地说，它只是准闭包，并不是真正的闭包。 什么是准闭包？若将闭包比作是一个人的修炼境界，那么准闭包就是人从一个境界快要突破到另一个境界的过渡期，此刻他已经初窥另一个境界的门道但尚未真正突破。 例子中，par()函数嵌套了另一个函数chi()，chi()函数调用par()函数词法作用域内的变量a。这些规则都是闭包规则的一部分，而且是非常重要的一部分。 也就是刚开始我们介绍到的闭包两个重要组成部分：函数嵌套和垮作用域引用。但上述变量a实现了垮作用域，但a所在的作用域依旧没有实现“跨作用域引用”，因此它只能是准闭包，并不是真正的闭包。 接下来我们看另外一个例子，清晰地展示闭包到底长什么样：1234567891011121314// 例子Bfunction par() &#123; var a = 1; function chi() &#123; console.log(a); &#125; return chi;&#125;var out = par();out(); // 1 上述例子就是一个经典的闭包教科书例子。 函数chi()的此法作用域能够访问par()的内部作用域，然后我们将chi()函数本身当作一个值类型进行传递给到外面。在par()函数执行后，其返回值（也就是它的内部chi()函数）赋值给out并调用out()，实际上只是通过不同的标识符引用调用了内部的函数bar(). 对比上述两个例子，它们不同之处在于：第一个例子chi()在自己定义的作用域内执行，而第二个例子chi()则将它传递到外面，在它定义作用域外执行。 我们都知道，通常情况下，一个函数执行完后（后面不再被利用），js引擎为节省内存会利用垃圾回收机制，将函数内部的作用域销毁，回收函数内部的内存。 然而，闭包的神奇之处，就是阻止这件的事情发生。事实上，闭包内部作用域依旧存在，不会被销毁。 例如上述例子A，par()函数执行完后，其内部作用域将被销毁，变量a被回收；而例子B，par()函数执行完后（倒数第二行），chi函数被赋予变量out，而由于chi()函数引用了par()内部的a变量，因此其内部作用域得以存活并不会被销毁。 最终，chi()依然持有对par作用域的引用，而这个引用就叫做“闭包”。 也就是域外引用a所在的作用域，“跨作用域引用”的真正含义。 注意：这里指的是对作用域的引用，并不仅仅指的是对作用域中变量a的引用，网上有很多文章认为对某一个变量的域外引用就是闭包，这种观点不敢苟同，对作用域中变量a的跨域引用只是是闭包的一个表现而已，并不是闭包的本质和含义。闭包在“域”而不在“量”。 当然，无论使用何种形式，实现上述所谓的跨作用域引用另外一个作用域，它就是闭包。 这种形式有很多，通常都是通过嵌套函数方式，但其他的方式尚未想到，这里姑且将“嵌套函数”作为闭包先决条件之一，更深层的含义则是“垮作用域引用” 例如：1234567891011121314// 例子Cfunction par() &#123;// par作用域 var a = 1; function chi() &#123;// chi作用域 console.log(a); &#125; other(chi);&#125;function other(tt) &#123;// other作用域 tt(); // 1 闭包&#125; 上述other()函数中执行tt()函数，而tt()函数是par()函数传递它的内部函数chi()域外，而chi()持有对原始定义par作用域的引用，因此它是闭包。 即无论通过何种手段将内部函数传递到它本身所在作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 3、闭包的应用前面的例子只是为了向大家展示闭包的真正含义，为了解释闭包进行了人为的修饰。日常业务代码中还有很多闭包的例子，比如： 123456function sayHelloAfterTime(var name, var sec=1) &#123; setTimeout(function () &#123; console.log("hello, I'm " + name) &#125;, sec*1000)&#125;sayHelloAfterTime("Jack"); // hello, I'm Jack 分析：由于setTineout将内部匿名函数传递到sayHelloAfterTime外部执行，而匿名函数引用sayHelloAfterTime作用域，因此属于闭包 1234var targ = document.getElementById('test');targ.addEventListener('click', function () &#123; console.log('hello');&#125;, false); 分析：由于addEventListener将内部匿名函数传递到点击事件click的外部执行，而匿名回调函数引用click事件作用域，因此属于闭包 注意：由于闭包是作用域的引用，而this也是作用域的引用，需要注意调用闭包后，此作用域非彼作用域，需要注意匿名函数中this的调用，比如：12345678910function sayHelloAfterTime(var name, var sec=1) &#123; function aa() &#123; console.log("aa") &#125; setTimeout(function () &#123; console.log("hello, I'm " + name) this.aa() // 会提示aa为undefined，此this非彼this &#125;, sec*1000)&#125;sayHelloAfterTime("Jack"); // hello, I'm Jack 上面的类似例子我们会经常用到吧，如果你熟悉Jquery一定会知道下面这个例子：123(function($)&#123; // ……&#125;)(jQuery) 这也属于闭包。 闭包的影子其实无处不在，本质上无论何时何地，如果将函数当作第一级的值类型并向外传递（垮作用域引用产生了），你就会发现闭包的影子。 在定时器，事件监听器，Ajax请求，垮窗口通信，Web Worker或者任何异步/同步任务中，只要使用了回调函数，实际上就是在使用闭包。 下面让我们看看前端精英们使用闭包而创造了不朽的作品： 1）JQuery的应用：前端模块设计的代表之作，利用了闭包的编程方式和原理，因此减少了命名冲突，避免污染全局环境； 2）sessionStorage的应用：前端缓存设计的代表之作，javascript没有私有成员的概念，利用了闭包的编程方式和原理，既实现了缓存的效果，节省访问时间，同时将key封装成私有变量，只能通过set和get方法访问。 向伟大的工程师们致敬！ 4、总结闭包的影子其实在我们身边无处不在，你不必为了刻意引用闭包而创建闭包代码，它只是javascript编程中自然而然出现的产物，然而掌握它将对我们理解javascript编程有重要意义，就像欣赏艺术一样编写javascript程序，javascript编程因它而变得更加神奇而又玄妙。倘若将普通的代码块理解为普通人类的话，那么闭包就是人类中的艺术家。 闭包有两个重要的组成部分：嵌套函数和跨作用域引用，理解这两个含义即可窥探它的奥义。 闭包当然也有其自身的缺陷（内存没有及时释放，this的引用等），如果没有真正理解其含义而滥用闭包将造成不可想象的后果，我们不需要刻意地去引用闭包，而需要时刻保持清醒的头脑，合理地科学地使用闭包。 5、参考1.《你不知道的JavaScript》p43-57]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>你不知道的javascript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的javascript系列-初探js编译机制]]></title>
    <url>%2F2019%2F04%2F23%2Fyou-dont-know-js-1%2F</url>
    <content type="text"><![CDATA[1、背景与其他编译型语言不同，javascript是一种解析型语言。这并不是说解析型语言就没有编译阶段，它运行时会进行两个阶段：编译和执行。那么它的编译过程是怎样的呢？ 2.编辑机制直观上理解javascript是在运行时一行一行代码往下执行的，但实际上并非如此。 考虑下面的例子：1234// 例子Aa = 1;var a;console.log(a); 你认为输出的结果会是什么呢？ 有人会认为第一行就会抛出错误，也有人认为最终会输出undefined，但其实上述代码没有问题，最终输出的结果为1. 让我们再看另外一个例子：123// 例子Bconsole.log(b);var b = 1; 你认为输出的结果会是什么呢？ 有人认为上述代码在第一行就会抛出异常，或者认为上述最终会输出1，但其实上述代码最终输出的结果会是undefined. 由上述例子我们可对js编译阶段有了初步的了解，编译阶段的一部分工作就是找到所有声明，并使用合适的作用域将他们关联起来。关于作用域，前面有介绍过《高性能JavaScript系列-作用域管理原理》 让我们再次回忆一下《编译原理》中的编译过程： 1）词法分析2）语法分析3）语义分析和中间代码生成4）优化5）目标代码生成 javascript引擎进行编译的步骤与传统编译语言的编译步骤非常相似，在某些步骤中会比预想中要复杂。 在前三个阶段当中，其实作用域已经很明了，包括变量和函数在内的所有声明都会在任何代码执行前首先被处理。这也间接说明为什么不建议使用eval和with等函数。 根据上述编译过程的第三阶段，那么我们回过头分析上述例子A：1234// 例子A-分析a = 1; // 赋值，等待执行var a; // 声明，并被提取到当前作用域最顶端console.log(a); // 打印，等待执行 那么最终目标代码生成如下：1234// 例子A-分析var a;a = 1;console.log(a); 同理，可自行分析例子B。 至此，你是不是对js编译机制有了初步的认识？ ^……^ 接下来，让我们看另外一个例子C：1234// 例子Cc = 1;let c;console.log(c); ES6新增两个属性let和const，let通常要与var对比理解才更深刻一些。上述例子C与前面提到的例子A非常相似，那么结果是不是一样都输出1呢？答案是否定的，输出的结果是第一行会抛出异常c is not undefined。 两个例子几乎是一致的，编译过程也是一样的，结果却是天壤之别，下面让我们分析一下。 let与var最大的差别是：let声明时会立刻创建一个块作用域，并提取到创建块作用域的顶端；而var并没有块作用域概念，通常充当一个全局作用域的角色，会被提取到当前全局作用域的最顶端。具体详情可参考前面提到的《高性能JavaScript系列-作用域管理原理》 因此，例子C分析如下： 1234// 例子C-分析c = 1; // 赋值，等待执行let c; // 声明，创建块作用域，并被提取到当前作用域最顶端console.log(c); // 打印，等待执行 那么最终目标代码生成如下：123456// 例子C-分析c = 1;&#123; let c; console.log(c);&#125; 因此，这也是为什么在第一行就抛出c is not undefined的异常错误。 3.总结1）包括变量和函数在内的所有声明都会在任何代码执行前首先被处理。2）当变量和函数出现相同名称时，函数声明会被优先提升（var类型变量），与声明的顺序无关。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>你不知道的javascript</tag>
        <tag>编译机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Web Worker]]></title>
    <url>%2F2019%2F04%2F10%2Fjs-web-worker%2F</url>
    <content type="text"><![CDATA[1.背景javascript采用的是单线程模型，随着时代的进步，单线程编程已无法充分发挥多核CPU计算机的计算能力，而Web Worker的出现为javascript创造了多线程编程，为未来javascript的发展提供另外一种新思路，这并不是说javascript未来会将单线程模型改为多线程模型，因为涉及到一个核心问题，假设javascript有两个线程，一个线程要添加dom节点，另外一个线程要删除这个节点，那浏览器引擎要以哪个为准呢？因此单线程模型将来也不会改变。Web Worker的出现只是为javascript提供了一种多线程编程模式，但并未改变javascript核心本质单线程模型。因为Web Worker本身有很多的限制，不允许操作DOM，且受主线程的控制。那么什么是“主线程”？ 用于执行javascript和更新用户界面的进程通常被称为“浏览器UI线程”（尽管对所有浏览器来说，称为“线程”不一定准确, 以下我们将其简称为“主线程”）。通常情况下，执行javascript和更新用户界面是交替进行的，倘若执行javascript时间过长，势必会出现界面“假死”现象。为了更优雅地解决这种情况，Web Worker应运而生。 2.基础部分2.1 web worker特性 web worker有自己的特性，有些属性名称与window中的属性名称相同，但其功能只是后者特性的一个子集。由于web worker线程的设计理念就是为减轻主线程计算方面问题，因此跟UI渲染相关对象不能也不应该读取。 2.1.1 web worker重要特性1）navigator对象（只有四个属性appName、appVersion、userAgent、platform） 2）location对象（属性与window.location相同，但所有属性都是只读） 3）self对象（指向worker线程用例自身） 4）XMLHttpRequest对象 5）setTimeout/setInterval方法 6）importScript()方法 7）close()方法 8）所有ECMAScript对象，如Object/Array/Date等 2.1.2 web worker不能读取特性1）DOM对象 2）window对象 3）document对象 2.2 基本用法2.2.1 web worker 的API 主线程属性 属性名称 Worker.onmessage 接收消息函数 Worker.postMessage 向worker线程发送消息函数 Worker.onerror worker线程错误监听函数 Worker.onmessageerror 接收消息错误监听函数（发送数据无法序列化成字符串时触发） Worker.terminate 关闭worker线程函数 worker线程属性 属性名称 self.onmessage 接收消息函数 self.postMessage 向主线程发送消息函数 self.onmessageerror 接收消息错误监听函数（发送数据无法序列化成字符串时触发） self.importScripts 加载外部js函数 self.close 关闭worker线程函数 2.2.2 主线程创建worker首先让我们看看如何创建worker线程：1const myworker = new Worker(jsURL, options) 参数说明： jsURL: 必选，worker将执行的脚本的url（必须同源）options: 可选，该对象包括{type, credentials, name}属性例子如下：1234// main.jsvar myworker = new Worker('my_worker.js')var myworker = new Worker('my_worker.js', &#123;name: 'my_worker', type: 'listen_status'&#125;) 2.2.3 主线程发送数据主线程向子线程发送一个“Jack”字符串数据：12// main.jsmyworker.postMessage('Jack') 2.2.4 主线程接收数据主线程接收子线程返回的数据，并打印出来：12345// main.jsmyworker.onmessage = function(event) &#123; console.log(event.data) ...&#125; 2.2.5 worker线程接收数据子线程接收主线程的数据并打印：12345// my_worker.jsself.onmessage = function(event) &#123;// self指向my_worker线程当前用例 console.log(event.data) ...&#125; 2.2.6 worker线程发送数据子线程向主线程发送一个“hello”字符串的数据：12// my_worker.jsself.postMessage('hello') 2.2.7 终止worker若我们想要关闭子线程，我们可以在主线程中直接关闭，方法为：12// main.jsmyworker.terminate() 我们也可以在子线程中直接关闭，通常在子线程任务结束后关闭，方法为：12// my_worker.jsself.close() 2.2.8 错误处理主线程可以监听worker线程是否发生错误，并做出相应的处理1234567// main.jsmyworker.onerror(function(e) &#123; var line = e.lineno // 错误文件行号 var filename = e.filename // 错误文件名 var msg = e.message // 错误内容 console.error('line:'+line+' in '+filename+': '+msg)&#125;) 2.2.9 加载外部文件子线程可以通过importScripts()方法引入其他脚本，接收0个或者多个url作为参数来引入资源1234// my_worker.jsimportScripts() // 什么都不引入importScripts('file1.js') // 加载一个文件importScripts('file1.js', 'file2.js') // 加载两个文件 2.2.10 完整小用例下面我们通过看一个完整的小用例，看看主线程与子线程的交互过程：12345678// main.jsif (window.Worker) &#123; var myworker = new Worker('my_worker.js') myworker.postMessage('Jack') myworker.onmessage = function(event) &#123; console.log(event.data) // hello, Jack &#125;&#125; 123456// my_worker.jsself.onmessage = function(event) &#123; console.log(event.data) // Jack self.postMessage('hello, '+ event.data) self.close()&#125; 注意： 上述以on开头的函数是一个回调函数，都可以使用addEventListener替换，如slef.onmessage(function)等同于self.addEventListener(‘message’, function)。如果你细心会发现一件很有趣的事情，在javascript衍生的技术或语言，它们的设计者都遵循这样一种规则：所有以on开头的函数都可以作为一种回调函数。子线程中其实也可以嵌套创建另外一个子线程，可以一直嵌套创建下去，但对应的逻辑就会变得复杂，不建议这样做。 至此，Web Worker基础使用方法已经介绍完毕。当然，我们知其然，应当知其所以然。 3.进阶部分事实上，Web Worker定义了两类工作线程：专用线程和共享线程。上述介绍的是专用线程。专用worker只能在一个页面所使用，而共享worker可以被多个页面所共享。创建共享worker的代码如下：1var shareworker = new SharedWorker('share_worker.js') 共享worker和专用worker它们的API基本上是一致的，除了名称不同以外，其实它们之间的最大区别在于它们的数据通信方式。共享worker通过端口port连接进行通信，在通信之前必须打开该端口，打开方法为:123456789// main.jsshareworker.port.start()shareworker.port.onmessage = function(e)&#123;&#125;shareworker.port.postMessage()// share_worker.jsself.port.start()self.port.onmessage = function(e)&#123;&#125;self.port.postMessage() 如果主线程与共享线程之间需要双向通信，那么它们都需要调用start()方法。同时，使用API接口方法时也需要通过port来调用，如上述代码例子，这里就不一一展开说明了。 下面将进一步解析主线程与worker线程并行执行的关系流程，主线程与worker线程的数据通信方式，以及worker线程的实际应用场景。 3.1 主线程与worker线程下面看看主线程与子线程运行时的关系图： 如上图，javascript主线程执行过程中，异步创建worker线程，然后主线程将继续执行其他任务。倘若worker线程还没有创建完成，主线程就直接通过worker.postMessage发送消息给Worker线程，该消息会进入一个临时消息队列中，等worker线程创建成功后，worker线程会从临时消息队列中接收消息，并处理。等处理完成后，通过self.postMessage将消息发送会主线程中。主线程接收到消息后，等待主线程处理完其他任务片段后，才会继续执行worker.onmessage中的回调函数。 在worker线程创建完成的前提下，主线程再次发送消息给worker线程时，worker线程会直接收到消息，而不必经过临时消息队列，如上图对应的交互过程1和2。 最后，当任务结束后，主线程和worker线程都可以关闭worker线程，主线程通过worker.terminate关闭，worker线程通过调用自身的self.close()关闭。 主线程和worker线程发送消息和接收消息流程基本相同，然而事实上，由于主线程受到内核任务调度的影响，worker线程发送的消息，主线程未必会收到消息就会马上往下执行，需要等待前面的任务执行完成才会继续往下执行；而主线程正确发出消息后，worker线程一般会收到消息就会继续往下执行。 3.2 数据通讯方式主线程与worker线程数据通信中传递的内容一般有两种，一种是传递原始值（字符串，数字，布尔值，null和undefined），另一种是传递object和Array的实例，其他的类型就不可以了。 当传递的内容为原始值时，传递的内容将被串行化，然后将串行化的字符串发送给worker线程，然后再还原，反过来亦是如此； 当传递的内容是对象或文件时，传递的内容将进行二进制转换，然后将二进制数据发送给worker线程。 其实若是了解java的同学，可以将这一过程理解为序列化和反序列化的过程。 由此可知，主线程与worker线程之间的通信数据，是一种拷贝关系，即值传递，而不是传址。worker线程改变传递进来的数据并不会影响到主线程。 既然是一种值传递的拷贝关系，倘若传递的数据很大，比如100M的文件（转化成二进制数据），默认情况下浏览器会生成一个原文件的拷贝，就会引起很大的性能问题。 为了解决这个问题，worker线程提供了一种方法叫做Transferable Objects，允许主线程把二进制数据直接转移给worker线程，但一旦转移，主线程将无法使用这些二进制数据。这对处理影音文件，3D运算，图片处理等意义重大，方法如下：123456// Transferable Objects语法worker.postMessage(arrayBuffer, [arrayBuffer])// 示例var arrbuf = new ArrayBuffer(1);worker.postMessage(arrbuf, [arrbuf]) 3.3 实际应用场景Web Worker适用于处理纯数据，或者与浏览器UI无关的长时间运行脚本。 那么我们如何定义日常UI响应为长时间呢？多久才算“长时间”，300毫秒，500毫秒，还是1秒？ 事实上，据国外专家研究，单个JavaScript操作花费的总时间不应该超过100毫秒。当然不包括文件上传和下载这种操作，这里针对的只是一般的UI响应场景 考虑这样一个例子：解析一个很大的JSON字符串，假设其数据量很大至少需要5000毫秒才能完成解析。很明显，它远远超出客户端允许javascript运行的时间，将严重影响用户体验。这种场景下，worker线程则成为最理想的解决方案。代码如下：123456789101112131415// main.jsif (window.Worker) &#123; var worker = new Worker('my_worker.js'); worker.onmessage = function(e) &#123; var jsonData = e.data; // 业务中处理json数据的函数 doSomething(jsonData); &#125; worker.postMessage(jsonStr); // 业务中处理json数据的函数 function doSomething(jsonData) &#123; // …… &#125;&#125; 123456// my_worker.jsself.onmessage = function(e) &#123; var jsonStr = e.data; var jsonData = JSON.parse(jsonStr); self.postMessage(jsonData);&#125; 解析一个大字符串只是web worker其中一个应用场景，典型的应用场景如下： 1）编码/解码大字符串2）复杂的数学运算（包括图像或视频处理）3）大数组排序 事实上，任何超过100毫秒的处理过程，都应该考虑Worker线程方案处理，当然前提是浏览器支持Web Workers。 4.总结由上所述，Web Worker的出现，充分发挥了多核CPU计算能力，解决浏览器单线程中高负载计算的问题，提升了用户体验。由浏览器的渲染原理可知，浏览器的主线程任务包括两部分：渲染任务和js解析任务，而Web Worker只是js解析任务中的一部分，处理计算相关的任务，因此它有自己的特性，不可以直接调用window中的绝大部分对象，dom对象以及document对象。 5.参考1.【MDN文档Web Worker API介绍】https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/Worker2.【MDN文档Web Worker API使用】https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers3.【高性能JavaScript】第6章 快速响应的用户界面4.【阮一峰的Web Worker 使用教程】http://www.ruanyifeng.com/blog/2018/07/web-worker.html5.【腾讯AlloyTeam 深入理解Web Worker】http://www.alloyteam.com/2015/11/deep-in-web-worker/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web worker</tag>
        <tag>js多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现鼠标可拖拽的div]]></title>
    <url>%2F2019%2F03%2F12%2Fjs-drag-div%2F</url>
    <content type="text"><![CDATA[1、背景最近公司项目的一项功能，是基于一个可拖拽的div基础上实现其业务逻辑的。经过探索，有两种实现方式，分别是基于mousedown和drag技术实现的。下面把遇到的一些坑记录下来，希望对小伙伴们有帮助^-^ 下面页面代码是react代码，但实现的思想是一致的。 2、基于mousedown技术这种技术是目前网络中较为“流行”的技术，意思就是随便google一下，网络上就会有一大堆，然而这种技术在某些应用场景下会存在一些不可避免的缺陷，下面会讲到。 事件流程： 1）onmousedown：触发拖拽2）onmousemove：实现拖拽3）onmouseup：清除拖拽监听 12345678910111213141516171819202122232425262728293031323334353637class TestTab extends Component &#123; constructor (props) &#123; super(props) this.state = &#123; x: 0, y: 0 &#125; &#125; handleOnMouseDown (e) &#123; e.preventDefault() document.onmousemove = (ev) =&gt; &#123; ev.preventDefault() this.setState(&#123; x: ev.clientX, y: ev.clientY &#125;) &#125; document.onmouseup = (ev) =&gt; &#123; ev.preventDefault() document.onmousemove = null document.onmouseup = null &#125; &#125; render () &#123; const &#123; x, y &#125; = this.state return ( &lt;div className='parent' style=&#123;&#123; left: x, top: y &#125;&#125; onMouseDown=&#123;e =&gt; this.handleOnMouseDown(e)&#125;&gt; &lt;div className='child' style=&#123;&#123; 'height': '200px', 'width': '300px', 'border': '1px solid red' &#125;&#125;&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 上述便可实现最简单的拖拽效果 然而，上面会出现这样一个问题，正常业务中，拖拽往往只能限制在一定地区域内拖拽，比如不能拖拽出window窗口(调试模式下)，不能拖出某个区域。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class TestTab extends Component &#123; constructor (props) &#123; super(props) this.lx = 5 this.rx = 60 this.ty = 50 this.state = &#123; x: 10, y: 60, &#125; &#125; handleOnMouseDown (e) &#123; //…… document.onmousemove = (ev) =&gt; &#123; //…… let cx = ev.clientX let cy = ev.clientY const dx = Math.max(0, this.maxX - this.rx) const dy = Math.max(0, this.maxY - this.ty) cx = Math.max(cx, this.lx) cy = Math.max(cy, this.ty) cx = Math.min(cx, dx) cy = Math.min(cy, dy) this.setState(&#123; x: cx, y: cy &#125;) &#125; document.onmouseup = (ev) =&gt; &#123; //…… &#125; &#125; showTip (e) &#123; // console.log(e.clientX, e.clientY) &#125; render () &#123; const &#123; x, y &#125; = this.state const ww = window.innerWidth || window.clientWidth const wh = window.innerHeight || window.clientHeight this.maxX = ww this.maxY = wh return ( &lt;div className='parent' style=&#123;&#123; left: x, top: y &#125;&#125; onMouseDown=&#123;e =&gt; this.handleOnMouseDown(e)&#125;&gt; &lt;div className='child' style=&#123;&#123; 'height': '200px', 'width': '300px', 'border': '1px solid red' &#125;&#125; onClick=&#123;e =&gt; this.showTip(e)&#125;&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 上述限制其不能拖拽超过某个区域（具体区域根据自己的业务场景进行设定） 然而实际业务过程中我们会在class为parent或者child的div层进行各种点击事件，这样就会出现这样一个问题，触发父元素parent拖拽动作onMouseDown的同时，也会触发子元素child的onClick事件，这并不是我们希望看到的，然而从dom元素的冒泡事件，这本身就是不可避免地会触发，这是它的硬伤。 1）当然也想过用e.stoppropagation()阻止冒泡，然并卵~。2）通过拖拽距离判断是否属于拖拽还是点击，然并卵~3）通过拖拽时间判断是属于拖拽还是点击，好像是能解决绝大部分场景…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class TestTab extends Component &#123; constructor (props) &#123; super(props) this.lx = 5 this.rx = 60 this.ty = 50 this.state = &#123; x: 10, y: 60, &#125; &#125; handleOnMouseDown (e) &#123; //…… const downTime = Date.now() this.moveTime = 0 document.onmousemove = (ev) =&gt; &#123; //…… let cx = ev.clientX let cy = ev.clientY const dx = Math.max(0, this.maxX - this.rx) const dy = Math.max(0, this.maxY - this.ty) cx = Math.max(cx, this.lx) cy = Math.max(cy, this.ty) cx = Math.min(cx, dx) cy = Math.min(cy, dy) this.setState(&#123; x: cx, y: cy &#125;) &#125; document.onmouseup = (ev) =&gt; &#123; this.moveTime = Date.now() - downTime // 拖拽时长 //…… &#125; &#125; showTip (e) &#123; // console.log(e.clientX, e.clientY) console.log("拖拽时长:", this.moveTime) if (this.moveTime &amp;&amp; this.moveTime &lt; 150) &#123; // 小于150ms才认为是点击事件，否则认为是拖拽事件 //……业务代码 &#125; &#125; render () &#123; const &#123; x, y &#125; = this.state const ww = window.innerWidth || window.clientWidth const wh = window.innerHeight || window.clientHeight this.maxX = ww this.maxY = wh return ( &lt;div className='parent' style=&#123;&#123; left: x, top: y &#125;&#125; onMouseDown=&#123;e =&gt; this.handleOnMouseDown(e)&#125;&gt; &lt;div className='child' style=&#123;&#123; 'height': '200px', 'width': '300px', 'border': '1px solid red' &#125;&#125; onClick=&#123;e =&gt; this.showTip(e)&#125;&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 上述，通过拖拽时长小于150ms的认为是点击事件，超过这个时长的认为是拖拽事件，好像是能解决绝大部分场景，然并卵~~ 最终，这都是旁门左道投机取巧而已~~并不完善，最终坑的还是用户体验 3、基于drag技术用drag技术解决才是最终的王道，抛开浏览器的兼容性问题，目前绝大部分主浏览器都已经兼容H5的drag方法，在caniuse上查询对比mousedown和drag，后者还更优一些。 事件流程： 1）ondragstart：触发拖拽起始位置2）ondrag：移动拖拽（可选，可略过这一步）3）ondragend：定位拖拽目标位置，实现拖拽 123456789101112131415161718192021222324252627282930313233343536373839404142class TestTab extends Component &#123; constructor (props) &#123; super(props) this.state = &#123; x: 0, y: 0 &#125; &#125; _onDragStart (e) &#123; // console.log('_onDrag:', e.clientX, e.clientY) &#125; _onDrag (e) &#123; // console.log('_onDrag:', e.clientX, e.clientY) &#125; _onDragEnd (e) &#123; // console.log('_onDragEnd:', e.clientX, e.clientY) this.setState(&#123; x: e.clientX, y: e.clientY &#125;) &#125; showTip (e) &#123; // console.log("onclick") &#125; render () &#123; const &#123; x, y &#125; = this.state return ( &lt;div className='parent' style=&#123;&#123; left: x, top: y &#125;&#125; draggable onDragStart=&#123;e =&gt; this._onDragStart(e)&#125; onDrag=&#123;e =&gt; this._onDrag(e)&#125; onDragEnd=&#123;e =&gt; this._onDragEnd(e)&#125;&gt; &lt;div className='child' style=&#123;&#123; 'height': '200px', 'width': '300px', 'border': '1px solid red' &#125;&#125; onClick=&#123;e =&gt; this.showTip(e)&#125;&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 上述，即可实现最简单的拖拽div效果，并且拖拽父元素parent过程中绝对不会触发子元素child的click点击事件。完美解决基于mousedown技术实现拖拽留下的硬伤。 然而，这个时候又会出现新的问题 1）拖拽位置不准确，即从A位置拖拽到B位置，最终的位置不准确，误差拖拽时起始的鼠标坐标。假设A（2，2），起始鼠标拖拽位置（3，3），期望目标B（9，9），最终实际目标为（8，8），与期望目标位置不符。这是由于拖拽的起始鼠标位置引起的，拖拽的div本身尺寸越大，效果就越明显，最终通过计算可以解决该问题，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class TestTab extends Component &#123; constructor (props) &#123; super(props) this.lx = 5 this.rx = 60 this.ty = 50 this.state = &#123; x: 10, y: 60 &#125; &#125; _onDragStart (e) &#123; // console.log('_onDragStart:', e.clientX, e.clientY) const &#123; x, y &#125; = this.state this.sx = e.clientX - x this.sy = e.clientY - y &#125; _onDrag (e) &#123; // console.log('_onDrag:', e.clientX, e.clientY) &#125; _onDragEnd (e) &#123; // console.log('_onDragEnd:', e.clientX, e.clientY) let cx = e.clientX let cy = e.clientY cx = cx - this.sx cy = cy - this.sy // 解决限制拖拽区域问题 const dx = Math.max(0, this.maxX - this.rx) const dy = Math.max(0, this.maxY - this.ty) cx = Math.max(cx, this.lx) cy = Math.max(cy, this.ty) cx = Math.min(cx, dx) cy = Math.min(cy, dy) this.setState(&#123; x: cx, y: cy &#125;) &#125; showTip (e) &#123; // console.log("onclick") &#125; render () &#123; const &#123; x, y &#125; = this.state const ww = window.innerWidth || window.clientWidth const wh = window.innerHeight || window.clientHeight this.maxX = ww this.maxY = wh return ( &lt;div className='parent' style=&#123;&#123; left: x, top: y &#125;&#125; draggable onDragStart=&#123;e =&gt; this._onDragStart(e)&#125; onDrag=&#123;e =&gt; this._onDrag(e)&#125; onDragEnd=&#123;e =&gt; this._onDragEnd(e)&#125;&gt; &lt;div className='child' style=&#123;&#123; 'height': '200px', 'width': '300px', 'border': '1px solid red' &#125;&#125; onClick=&#123;e =&gt; this.showTip(e)&#125;&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 上述，基本解决遇到几个问题 4、总结1）基于mousedown技术开发拖拽div，存在实际业务的缺陷，虽然可以通过技巧解决，但并非是最好的解决方案2）基于drag技术开发拖拽div，相对来说不失为一种更好的解决方案，并且代码更精简，简约而不简单]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>可拖拽div</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随手笔记]]></title>
    <url>%2F2019%2F02%2F28%2Ftake-notes%2F</url>
    <content type="text"><![CDATA[1.图表绘制底层Canvas, SVG, VML的对比，各适用场景1.性能对比：Canvas的性能受画布尺寸大小影响更大，SVG的性能受图形元素个数影响更大；2.适用场景：2-1）Canvas可以轻松应对大量数据和动态特效展现的场景；2-2）SVG可以在移动端展示，使其不再为内存而担忧；2-3）VML可以兼容低版本IE； 2.let和var区别1.let定义了块级作用域，只在代码块内有效；2.let在同一作用域内，不允许重复声明同一个变量，但允许在垮作用域声明同一个变量；3.ES5只有全局作用域和函数作用域： 全局作用域，局部作用域会覆盖全局作用域函数作用域，用来计数的循环变量会泄露为全局变量12345678for (var i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i)// 10for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i)// 报错 此外，for的每一次循环相当于一个新的块级作用域，var是不断覆盖老的变量（在整个for循环体内有效），而let则是声明新的变量（只在本轮循环有效） 3.const变量1.const声明一个常量，它实际保证的并非是它的值不变，而是保证变量指向那个内存地址所保存的数据不得改动（对简单类型如数值，字符串，布尔值好理解，但对复合型如对象和数组，则需要理解指针地址的概念）2.const声明一个常量必须立刻初始化赋值；3.const作用域与let作用域相同； 4.js获取时间戳方法1) var cur = Date.parse(new Date());2) var cur = (new Date()).valueOf();3) var cur = new Date().getTime();4) var cur = Date.now(); 5.匿名函数的递归arguments.callee123456var i = 0;(function()&#123; console.log(i++) i === 60 &amp;&amp; i = 0; arguments.callee();&#125;)(); // 不断打印0-59的死循环 但是由于arguments.callee每次递归时需要重新创建，浪费内存资源，现已不推荐使用。 6.this的绑定规则及其优先级1）由new调用？绑定到新创建的对象2）由call或者bind(或者apply)调用？绑定到指定的对象（显式绑定）3）由上下文对象调用?绑定到那个上下文对象（隐式绑定）4）默认：在严格模式下绑定到undefined,否则绑定到全局对象 ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前词法作用域来决定this,具体来说，箭头函数会继承上一层函数调用的this绑定（无论this绑定到什么）。这其实与代码中的self=this机制是一样的。 摘自《你不知道的javascript》 7.创建对象的方法1）{}2）new Object()3) Object.create(null) 如果要访问对象中的一个属性，引擎实际上会先调用内部默认的[[Get]]操作，如果没有找到，就会通过[[prototype]]链来查找。 A和B的委托关系：B = Object.create(A) 8.prototype机制[[Prototype]]机制就是指对象中的一个内部链接引用另一个对象。本质就是对象之间的关联关系。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>let var const</tag>
        <tag>canvas svg vml</tag>
        <tag>js时间戳</tag>
        <tag>你不知道的javascript</tag>
        <tag>高性能javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium自动化测试入门篇]]></title>
    <url>%2F2019%2F02%2F13%2Fselenium1%2F</url>
    <content type="text"><![CDATA[前言在使用selenium+python实践过自动化测试项目一段时间后，决定将此实践过程记录下来，以便后来的学习者提供借鉴。这里的例子基于h5archetype项目 自动化测试的工具有很多，selenium+python只是其中的一种组合方式，不必纠结于使用什么测试工具，关键看你怎么利用好这些工具 1.环境准备1-1）selenium 测试框架（必须）1-2）python36 编程语言（必须）1-3）pycharm 编辑器（必须）1-4）chromedriver.exe 浏览器引擎（必须）1-5）sqlalchemy 数据库连接引擎（可选，需要连接数据库必须）1-6）cx_Oracle 数据库连接库（可选，需要连接Oracle数据库必须） 2.安装环境2-1）安装python36 编程语言 2-2）安装pycharm 编辑器 下载社区版即可，不需要专业版（为什么选择pycharm编辑器，难道其他的编辑器就不行吗？别急往下看） 2-3）安装chromedriver.exe 浏览器引擎（仅针对chrome61版本，不同版本请自行选择下载） 谷歌浏览器版本与chromedriver.exe版本映射地址：https://blog.csdn.net/qq_40027987/article/details/79544489下载完成后，放入C:\Python36\Scripts目录中，然后将C:\Python36\Scripts配置到系统环境变量path中 2-4）在pycharm编辑器中引入其他环境依赖包打开pycharm编辑器，新建项目或引入h5archetype/frontend项目打开配置：File-&gt;settings→ 添加python36 添加selenium 按照添加selenium的方式，依次添加cx_Oracle，sqlalchemy， 如下图 如上图，所有环境依赖准备就绪后，点击OK即可 至此，环境已经安装完成！接下来，即可编写自动化编程 最后解答下前面提出的一个问题，为什么选择pycharm编辑器？答：从上面也可注意到，pycharm编辑器提供安装项目依赖环境，方便安装各种依赖包，使用系统window的python环境会出现目录文件找不着的情况。其他编辑器试了都是这种情况，如Intellij IDEA，vscode，eclise等。这是由于全局中的python查找目录文件的默认方式造成的，当然，你可以在引用其他目录文件时修改它的默认查找方式，但还是建议你使用pycharm编辑，既方便又省事。 3.运行项目将/frontend 自己的项目引入pycharm编辑器中进入test_auto/test/test_suite/sample目录，选择suite_sample_create.py或suite_sample_manage.py点击运行即可 如下图，运行Sample Manage页面的自动化测试 自动打开登录页面 自动打开Sample Manage页面，并自动测试设定的场景（如查询场景，编辑场景） 执行完成后，结果如下： 打开HTML结果报告 扩展：生成更好看的测试报告可以使用allure工具，详情点击 4.项目解析 自动化测试的作用：特别是在回归测试中作用发挥巨大，能帮助我们节省很多的时间和精力，节约成本。其实一个好的自动化测试项目应该有一个好的项目结构，相比于自动化测试工具，我认为项目结构更为重要，项目结构设计的好坏直接影响项目的可扩展性和维护性，也就是测试对象无论怎么变化，作为对应的自动化测试维护工作都应该尽可能少，且不影响测试结果的正确性。（自动化测试项目其实应该是个独立的项目，与各分支无关，不应跟在项目的某个分支下面，这里为了图方便与分支搅在了一起。） 以下是我们的项目结构： . ├── /common/ # 公共函数目录 ├── /config/ # 系统配置 ├── /db/ # 数据库连接目录 ├── /log/ # 日志函数目录 ├── /test/ # 测试目录 │ ├── /test_data/ # 测试数据 │ ├── /test_page/ # 测试逻辑 │ ├── /test_suite/ # 测试入口 其中/test作为项目的源码，将测试的数据，逻辑，运行入口进行分离。以页面作为测试对象，以页面操作场景作为最小测试单位（如新建场景，修改场景，查询场景等） 1）/test_data 存放查找页面元素css和各页面的测试用例 2）/test_page 存放各页面操作场景的逻辑 3）/test_suite 存放各页面可运行用例 5.相关技术介绍5-1）pythonpython作为最流行的编程语言之一，适合编写应用程序的高级编程语言，推荐教程：http://www.runoob.com/python/python-intro.html重点关注Python unittest 5-2）selenium作为最流行的自动化测试框架之一，它非常容易上手且相关社区较为活跃，遇到问题很容易就找到解决方法，推荐教程：http://selenium-python-zh.readthedocs.io/en/latest/getting-started.html 举个栗子（注意先准备好环境）12345678910111213#coding:utf-8from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.baidu.com/')# time.sleep(2)assert "百度一下，你就知道" in browser.titlebrowser.find_element_by_id('kw').send_keys('selenium')browser.find_element_by_id('su').click()time.sleep(3)# browser.close() # 关闭一个tab标签页browser.quit() # 关闭整个浏览器 说白了就是提供个web驱动，模拟用户的各种行为，如打开浏览器，输入度娘的网址，输入要查询的内容”selenium”, 然后点击查询，浏览3秒后关闭浏览器，看是不是很（hen）简（hai）单（sen）! 5-3）sqlalchemy作用：提供DB连接引擎，连接数据库，执行SQL官网地址：http://docs.sqlalchemy.org/en/latest/core/tutorial.html 举个栗子（注意先准备好环境）123456789101112131415161718192021222324252627282930# coding:utf-8from sqlalchemy import create_enginefrom sqlalchemy.orm import sessionmakerfrom sqlalchemy.ext.declarative import declarative_baseclass db_help: engine = create_engine('oracle://db_username:db_password@sql_address:sql_port/db_name', echo=False) #请先替换自己的oracle数据库对应的数据库名，登录名，密码 #构造函数 def __init__(self): Session = sessionmaker(bind=db_help.engine, autocommit=False) self.session = Session() print ('create session:') print (self.session) def getSession(self): return self.session #析构函数 def __del__(self): if self.session != None: print ('delete session') self.session.close() self.session = Nonedb = db_help()session = db.getSession()result = session.execute('select * from crm_user where username =:user_name', &#123;'user_name': 'admin'&#125;).fetchall()if len(result) &gt; 0: for item in result: print(item) 功能：查询crm_user表中admin的数据并打印出来]]></content>
      <categories>
        <category>selenium</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能JavaScript系列-高性能JavaScript读书笔记]]></title>
    <url>%2F2019%2F02%2F12%2Fhpjavascript8-1%2F</url>
    <content type="text"><![CDATA[1、js如何将十进制的数字转换成二进制？使用toString(2)进行转换即可，例如：12var num = 8;console.log(num.toString(2)); // "1000" 2、如何获取当前页面有多少个dom节点数？1console.log(document.getElementsByTagName('*').length); // "1000" 3、js打印函数方法运行时长1234567// 启动计时器console.time('testForTime');// 运行程序……// 停止计时console.timeEnd('testForTime')// 4343.123ms]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>高性能JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter系列-jmeter介绍]]></title>
    <url>%2F2019%2F02%2F11%2Fjmeter1%2F</url>
    <content type="text"><![CDATA[1、简介 测试系统的负载能力和性能测试工具纯Java开发支持多种类型服务和协议界面模式和命令行模式扩展性强 2、安装和启动下载地址：https://jmeter.apache.org/download_jmeter.cgi历史版本：https://archive.apache.org/dist/jmeter/binaries/加压后双击运行 jmeter-3.3/bin/jmeter.bat 即可 3、各元件介绍jmeter有许多的元件，如图： Jmeter元件主要包括： 1.逻辑控制器（controller）2.配置元件3.定时器4.前置处理器5.采样器（Sampler）6.后置处理器7.断言8.监听器 Jmeter各元件优先级顺序： 1.配置元件2.前置处理器3.定时器4.采样器（Sampler）5.后置处理器6.断言7.监听器 Jmeter各元件是以控制器（controller）和采样器（sampler）为中心，其他元件都是围绕这两个元件进行逻辑处理。采样器一般内嵌在逻辑控制器Controller中]]></content>
      <categories>
        <category>jmeter</category>
      </categories>
      <tags>
        <tag>jmeter学习笔记</tag>
        <tag>jmeter</tag>
        <tag>性能压测</tag>
        <tag>jmeter执行顺序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter系列-Jmeter线程组内各请求的执行顺序]]></title>
    <url>%2F2019%2F02%2F11%2Fjmeter2%2F</url>
    <content type="text"><![CDATA[1、背景在压测的过程中，我们不免会碰到一些疑惑，比如批量http的执行顺序，而这些顺序问题直接关系到我们的脚本逻辑的设计和压测结果的评估。 假设线程组一批请求中多次轮询，是否等每次轮询执行完成，才进行下一轮的请求？批量请求的http执行顺序是怎样子的？前一个http加入定时器后是否会影响下一个http请求？ 2、揭秘假设有5个http请求，其中第3个http加入固定定时器，等待3秒，如图 2.1、例子1-单个线程线程组控制参数，如下 执行结果如下： 可是我们的线程（模拟的用户数），通常情况下都不会只有一个，而是有多个 2.2、例子2-多个线程线程组控制参数，如下 执行结果如下： 如上图，对应的线程1，先执行线程1的第一轮和线程1的第二轮，接下来执行线程2，线程2的第一轮和线程2的第二轮……以此类推 答案是不是那么简单？ 如果真是这么简单，呵呵，我就没必要写这篇博客笔记了…… 2.3、例子3-多个线程调整启动时间我们调整线程组启动时间参数，如下 执行结果如下： 如上图，对应的线程组就不是按步就班地执行了，线程1，线程2，线程3所对应的第一轮前两个http先抢占cpu资源，先执行，等到线程1的第3个http等待3秒的时间到后，才执行线程1剩余的后3个http请求。 由此可见，前一个http加入定时器后会影响下一个http请求，等待资源期间，其他线程的http请求会抢占cpu，先执行；批量http请求的执行顺序与线程组启动时间有关； 3、总结1.同一线程组，同一轮http请求执行顺序，按从上到下顺序执行； 2.同一线程组，不同轮http请求执行顺序，与线程组的启动时间有关； 2-1）若启动时间远大于执行完一轮所需的时间，那么每一轮都会按步就班执行； 2-2）若启动时间小于执行每一轮所需的时间，那么其他线程就会直接抢占cpu资源，先执行]]></content>
      <categories>
        <category>jmeter</category>
      </categories>
      <tags>
        <tag>jmeter学习笔记</tag>
        <tag>jmeter</tag>
        <tag>性能压测</tag>
        <tag>jmeter执行顺序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter系列-使用Jmeter做阶梯式加压]]></title>
    <url>%2F2019%2F02%2F11%2Fjmeter4%2F</url>
    <content type="text"><![CDATA[1、背景有些场景，需要我们使用阶梯式加压，慢慢一批一批数量，逐渐往上加压，最高并发运行线程不能因为运行出错而减少虽然普通Thread Group也可以进行阶梯式加压，但由上一篇《Jmeter线程组内各请求的执行顺序》我们可以知道，若线程组启动时间参数设置不当，会造成线程组的加压方式并不会按照我们预想地”阶梯式加压”，有可能第一批线程还没跑完，就会先跑第二批线程。注意这里介绍的阶梯式加压，与普通Thread Group加压是有一些区别，具体后面会有介绍。 2、阶梯式加压Jmeter提供两种方式可以实现批量逐步往上加的效果，一是Stepping Thread Group，二是Concurrency Thread Group 下载方式： Jmeter Plugins Manager中下载Custom Thread Groups 如果选项中没有Plugins Manager（如下图），请自行下载，地址：https://jmeter-plugins.org/install/Install/ 使用Concurrency Thread Group,如图 Concurrency Thread Group比Stepping Thread Group优点： 1）并发线程组允许控制测试的长度2）线程在进程中间结束的情况下创建替换线程，节省内存（压测机器） 参数说明： Target Concurrency: 并发线程数 Ramp Up Time: 加速时间 Ramp-Up Steps Count: 加速步奏计数 Hold Target Rate Time: 保持目标速率运行时间 Time Unnit: 时间单位（分或秒） Thread Iterations Limit：线程迭代次数限制 Log Threads Status into File: 将线程状态记录到日志文件（线程启动和停止事件保存为日志文件） 举个栗子：Target Concurrency：10（A）Ramp Up Time： 10（B）Ramp-Up Steps Count: 10（C）Hold Target Rate Time: 1Time Unit: seconds（程序组内每个线程启动的定时器设置为1s） 由上图可以看出，每隔1s（10(C)/10(A)）启动一个线程。程序内部设置定时器也应该为1s，否则线程启动数量不可控 再达到目标线程10个，总的启动线程数量为：1+2+3+….+10 = 10(10+1)/2=55持续10个线程运行时间为1s，数量为：101=10（同理若持续为5s，则为10 * 5=50）总的线程数量为：55+10=65 注意：最终运行线程数量运算较复杂，非必要场景下，不推荐使用 3、总结Concurrency Thread Group与普通 Thread Group区别：1.最大的区别就是假设目标线程为100，运行过程中若有线程出错，普通线程组最终运行的目标线程会小于100，而Concurrency Thread Group最终运行的目标线程始终会保持100 2.普通线程组若想查看其中错误的线程出错，根据日志是很难查找得到的（当目标线程很大的情况下），而Concurrency Thread Group可以将错误的线程保存在日志文件中，更容易得到错误线程的报错信息]]></content>
      <categories>
        <category>jmeter</category>
      </categories>
      <tags>
        <tag>jmeter学习笔记</tag>
        <tag>jmeter</tag>
        <tag>性能压测</tag>
        <tag>阶梯式加压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter系列-Jmeter登录session共享]]></title>
    <url>%2F2019%2F02%2F11%2Fjmeter3%2F</url>
    <content type="text"><![CDATA[1、背景有很多情况，我测试的接口或场景与登录操作无关，而又必须先登录才拥有对应的接口权限，测试对应的接口。那么有哪些共享session的方法？ 2、共享登录session方式2.1、利用仅一次控制器共享session（单个线程组）利用简单的仅一次控制器，处理登录操作，如下图 提取登录请求的session，然后将其保存在一个变量中即可。 然而，上述方式只适用于在当前线程组内session共享，若需要跨线程组共享一个session，那就需要使用property属性。 2.2、利用property属性共享session（多个线程组）利用Jmeter本身提供的property属性，垮线程组的session共享，使用${ __setProperty(,,) }保存，如图 然后在要用的地方，使用${ __property() }提取， 如图 3、总结仅一次控制器适用于单线程组内共享session，property属性适用于多个线程组共享session]]></content>
      <categories>
        <category>jmeter</category>
      </categories>
      <tags>
        <tag>jmeter学习笔记</tag>
        <tag>jmeter</tag>
        <tag>性能压测</tag>
        <tag>session共享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM编程之渲染引擎原理]]></title>
    <url>%2F2019%2F02%2F11%2Fjs-browser-render%2F</url>
    <content type="text"><![CDATA[1、背景 浏览器引擎主要由两部分组成：渲染引擎（rendering engine）和js解析器（javascript interpreter） 参考浏览器工作原理：http://domenicodefelice.blogspot.com/2015/08/how-browsers-work.html?t=2]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>高性能JavaScript</tag>
        <tag>DOM编程</tag>
        <tag>渲染引擎原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能JavaScript系列-作用域管理原理]]></title>
    <url>%2F2019%2F02%2F11%2Fhpjavascript2-1%2F</url>
    <content type="text"><![CDATA[1、执行环境context首先我们需要理解什么是执行环境？其实可以简单理解为上下文执行环境，举个栗子： 1234function add(num1, num2)&#123; var sum = num1 + num2; return sum;&#125; 执行函数add时，会创建一个被称为执行环境（execution context）的内部对象，一个执行环境定义了一个函数执行时的环境。函数每次执行时对应的执行环境都是独一无二的，所以多次调用同一个函数会创建多个执行环境。当函数执行完成时，执行环境就会被销毁，一般情况下当垃圾回收机制开始执行时，会将其所有作用域变量销毁，但有一种情况是例外，那就是闭包，闭包却会阻止闭包本身所使用的作用域变量被销毁。 2、作用域链与活动对象每个执行环境都有自己的作用域链，用于解析标识符。如图 当执行环境被创建时，它的作用域链初始化为当前运行函数的[Scope]属性中的对象。这些值按照它们出现在函数中的顺序，被复制到执行环境的作用域链中这个过程一旦完成，一个称为“活动对象”(activation Object)的新对象在执行环境中创建好了如上图，活动对象与其他的对象在一个队列中，作用链的最顶端为活动对象，当执行环境被销毁，活动对象也随之销毁 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程： 搜索过程从作用域链头部开始搜索（当前活动对象）该变量标识符 如找到则使用，直接使用该标识符 如没有找到，继续搜索作用域链的下一个对象，直到找到为止 若作用域链中所有对象中都没有找到该标识符，那么该标识符被视为未定义的。 全局变量总是存在于执行环境作用域链的最末端，因此它是最远的。要想提高代码性能，请将函数内的全局变量转化成局部变量，提高读取标识符解析速度。 3、改变作用域链一般来说，一个执行环境的作用域链是不会改变的，但是有两个语句可以使其发生改变：1.with语句2.try-catch中catch子句 4、优化JavaScript代码策略1.访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢 2.由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨域变量更快。变量在作用域链的位置越深，访问的速度越慢。由于全局变量总处于作用域链的最末端，因此访问的速度也是最慢的 3.避免使用with语句，因为它会改变执行环境的作用域链，同样，try-catch语句中的catch子句也有同样的影响，因此要小心使用 4.嵌套的对象成员会明显影响性能，因此尽量少用 5.属性和方法在原型链中的位置越深，访问它的速度也就越慢 6.通常来说，你可以通过把常用的对象成员，数组元素，跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问的速度更快。以空间换时间的代价，需要自己权衡]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>高性能JavaScript</tag>
        <tag>作用域</tag>
        <tag>执行环境context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能JavaScript系列-无阻塞加载js文件]]></title>
    <url>%2F2019%2F02%2F11%2Fhpjavascript1%2F</url>
    <content type="text"><![CDATA[代码11&lt;script type=&quot;text/javascript&quot; src=&quot;file1.js&quot;&gt;&lt;/script&gt; 代码2 1234var script = document.createElement(&quot;script&quot;);script.type = &quot;text/javascript&quot;;script.src = &quot;file1.js&quot;document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script); 代码1与代码2的异同： 代码1在执行过程中，文件下载后会立刻执行，堵塞页面的其他进程（如其他下载进程） 代码2在执行过程中，文件下载和执行过程不会堵塞页面的其他进程，直到DOM加载完成，因此该方法可以与其他资源并行下载 有多种无堵塞下载JavaScript的方法： 1. 使用script标签的defer属性 2. 使用动态创建的script元素来下载并执行代码 3. 使用XHR对象下载JavaScript代码并注入页面中 以上三种方法各有缺点： 1-1) 支持的浏览器较少 2-1) IE内核浏览器需要额外处理 3-1) 不支持CDN下载]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>高性能JavaScript</tag>
        <tag>无堵塞加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒懂flex布局]]></title>
    <url>%2F2019%2F02%2F11%2Fcss-flex-layout%2F</url>
    <content type="text"><![CDATA[1、背景 我们知道一切dom元素对css而言都是一个盒子，css正是以盒子模型为基础进行渲染CSSDom，而页面布局一直是css一个应用重点，那么如何通过css实现水平居中和垂直居中？相信实现的方法有很多，如table，float等，但它们都有各自的缺陷。然而当flex出现后，一切都变得相当的简约而不简单，优雅而不优越，因为它也存在兼容性问题。12345.centerContainer &#123; display: flex; justify-content: center; align-items: center;&#125; 它的子元素就是水平和垂直居中，浏览器兼容性方面：IE10+ 详情点击这里 2、概念flex由两个核心概念构成：容器和轴。容器包括父容器和子容器，轴分为主轴和交叉轴（即以横轴为主轴时，纵轴为交叉轴；以纵轴为主轴时，横轴为交叉轴；交叉轴=主轴逆时针90度）。flex属性一共有12个，父容器和子容器对应的属性各6个。 3、属性介绍父容器属性 1) flex-direction (常用)2) justify-content (常用)3) align-items (常用)4) align-content5) flex-warp6) flex-flow 子容器属性 1) align-self (常用)2) flex (常用)3) flex-grow4) flex-shrink5) flex-basis6) order 3.1.常用属性介绍1) flex-direction功能：flex-direction属性用于确定主轴的方向（等同于确定了交叉轴的方向）使用：1234.box &#123; display: flex; flex-direction: row | row-reverse | column | column-reverse;&#125; 属性值 说明 row 主轴为水平方向，起点在左端（默认值） row-reverse 主轴为水平方向，起点在右端 column 主轴为垂直方向，起点在上 column-reverse 主轴为垂直方向，起点在下 效果：（效果图作者：osimly） 2) justify-content功能：justify-content属性用于定义如何沿着主轴方向排列子容器（主轴）使用：1234.box &#123; display: flex; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 属性值 说明 flex-start 左对齐（默认值） flex-end 右对齐 center 居中 space-between 两端对齐，子容器之间间隔相等 space-around 均匀分布，首尾两端的子容器到父容器的距离是子容器间距的一半 效果：（效果图作者：osimly） 3) align-items功能：align-items属性用于定义如何沿着交叉轴方向排列子容器（交叉轴）使用：1234.box &#123; display: flex; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 属性值 说明 flex-start 起始端对齐（默认值） flex-end 末尾端对齐 center 居中 baseline 基线对齐，即默认指首行文字为基线 stretch 拉伸对齐，子容器与父容器（高度/宽度）一致，相对于交叉轴方向而言 效果：（效果图作者：osimly） 4) align-self功能：align-self属性用于定义每个子容器自身如何沿着交叉轴方向排列（交叉轴），注意与align-items区别 align-self属性与align-items属性一致，若是一个子容器同时被定义了align-items和align-self，以align-self属性值为准。 使用：1234.box &#123; display: flex; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 属性值 说明 flex-start 起始端对齐（默认值） flex-end 末尾端对齐 center 居中 baseline 基线对齐，即默认指首行文字为基线 stretch 拉伸对齐，子容器与父容器（高度/宽度）一致，相对于交叉轴方向而言 效果：（效果图作者：osimly）align-self属性与align-items属性一致，若是一个子容器同时被定义了align-items和align-self，以align-self属性值为准 5) flex功能：flex是一个复合属性，用于定义子容器自身的的伸缩比例，它是flex-grow,flex-shrink和flex-basis属性的缩写使用：1234.box &#123; display: flex; flex: 0 1 auto;&#125; 属性值 说明 0 1 auto flex-grow,flex-shrink和flex-basis属性的缩写，具体查看这三个属性的说明（默认值） none 0 0 auto （flex属性值允许1个或2个或3个属性的连用） 效果：（效果图作者：osimly） 常用的flex属性基本就这5个，掌握这5个属性之后，一般场景下的布局设置可以基本实现了。倘若需要满足其他特殊的布局，那么就有必要进一步了解其他7个属性了。 3.2.进阶属性介绍1) flex-wrap功能：flex-wrap属性用于确定子容器是否需要换行使用：1234.box &#123; display: flex; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 属性值 说明 nowrap 不换行（默认值） wrap 换行 wrap-reverse 逆向换行 效果：（效果图作者：osimly） 2) flex-flow功能：flex-flow是一个复合属性，用于确定子容器的主轴方向和换行，是flex-direction和flex-wrap的组合使用：1234.box &#123; display: flex; flex-flow: row nowrap;&#125; 属性值 说明 row nowrap 左起水平方向主轴，且不换行（默认值） row 左起水平方向主轴。（flex的复合属性，都可以单独设置） 3) align-content功能：align-content属性用于确定子容器多行排列时，行与行之间的对齐方式（交叉轴），注意与align-items区别 align-items针对单行子容器在交叉轴上的排列，而align-content则针对多行子容器在交叉轴上的排列方式 使用：1234.box &#123; display: flex; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 属性值 说明 flex-start 起始端对齐（默认值） flex-end 末尾端对齐 center 居中 space-around 等边距均匀分布, 首尾两端的子容器到父容器的距离是子容器间距的一半 space-between 等间距均匀分布, 子容器之间的间距相等 stretch 拉伸对齐，多行子容器交叉轴方向长度相同，填满父容器 效果：（效果图作者：osimly） 4) flex-basis功能：flex-basis属性用于确定子容器自身在主轴方向的原始尺寸使用：1234.box &#123; display: flex; flex-basis: 100px;&#125; 属性值 说明 100px 子容器的原始宽度为100px（flex-direction默认为row，因此为宽度） 效果：（效果图作者：osimly）结合flex-grow属性说明会更清晰一些 5) flex-grow功能：flex-grow属性用于确定子容器自身在主轴方向的扩展比例使用：12345678910.box1 &#123; display: flex; flex-basis: 100px; flex-grow: 1;&#125;.box2 &#123; display: flex; flex-basis: 100px; flex-grow: 2;&#125; 属性值 说明 1 都是相对父容器而言，如上box1和box2为兄弟节点，父节点box宽度为480px，那么计算公式为：box.width = box1.width + box2.width = (120 + 1x) + (120 + 2x) = 480；即box1.width = 200px, box2.width = 280px; 效果：（效果图作者：osimly） 6) flex-shrink功能：flex-shrink属性用于确定子容器自身在主轴方向的收缩比例，注意与flex-grow的区别 flex-grow属性是伸展，flex-shrink属性是收缩使用：12345678910.box1 &#123; display: flex; flex-basis: 300px; flex-shrink: 1;&#125;.box2 &#123; display: flex; flex-basis: 600px; flex-shrink: 2;&#125; 属性值 说明 1 都是相对父容器而言，如上box1和box2为兄弟节点，父节点box宽度为480px，那么计算公式为：box.width = box1.width + box2.width = (480-x)+(480-2x) = 480；即box1.width = 320px, box2.width = 160px; 效果：（效果图作者：osimly） 7) order功能：order属性用于确定子容器自身在主轴方向的排列序号使用：1234.box1 &#123; display: flex; order: 0;&#125; 属性值 说明 0 排列的序号，值越小越靠前，允许为负值（默认值）; 效果：（效果图作者：osimly） 4、总结flex的每一个属性都是围绕着容器和轴两个概念而进行描述的。flex有两个复合属性，复合属性允许设置单个属性和多个属性align-self属性与align-items属性值相同，但两者设置的位置不同，前者在子容器中设置子容器自身属性，后者在父容器中设置子容器的属性，因此当同时设置子容器的属性时，以align-self的属性值为准常用的属性如下：flex-direction, justify-content, align-items, align-self, flex进阶的属性如下：align-content, flex-warp, flex-flow, flex-grow, flex-shrink, flex-basis, order复合属性如下：flex-flow, flex 参考一劳永逸的搞定 flex 布局：https://juejin.im/post/58e3a5a0a0bb9f0069fc16bbFlex 布局教程：语法篇：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>flex布局</tag>
        <tag>css3</tag>
        <tag>css居中</tag>
      </tags>
  </entry>
</search>
